package common

import (
	"io/ioutil"
	"testing"
)

func TestReadNetmapConfig(t *testing.T) {
	tests := []struct {
		name    string
		args    string
		wantErr bool
	}{
		{name: "CorrectWorkstationConfig", args: `
network0.name = "Bridged"


network0.device = "vmnet0" #comment
network1.name = "HostOnly"
network1.device = "vmnet1"
    #comment
network2.name = "VMNet2"
network2.device = "vmnet2"
network8.name = "NAT"
network8.device = "vmn
et8"
`, wantErr: false},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			f, err := ioutil.TempFile("", "test")
			if err != nil {
				t.Fatal(err)
			}

			err = ioutil.WriteFile(f.Name(), []byte(tt.args), 0666)
			if err != nil {
				t.Fatal(err)
			}

			_, err = ReadNetmapConfig(f.Name())
			if (err != nil) != tt.wantErr {
				t.Errorf("ReadNetmapConfig() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
		})
	}
}
func TestReadDHCPConfig(t *testing.T) {
	tests := []struct {
		name    string
		args    string
		wantErr bool
	}{
		{name: "CorrectDHCPConfig", args: `
# Configuration file for ISC 2.0 vmnet-dhcpd operating on vmnet1.
#
# This file was automatically generated by the VMware configuration program.
# See Instructions below if you want to modify it.
#
# We set domain-name-servers to make some DHCP clients happy
# (dhclient as configured in SuSE, TurboLinux, etc.).
# We also supply a domain name to make pump (Red Hat 6.x) happy.
#


###### VMNET DHCP Configuration. Start of "DO NOT MODIFY SECTION" #####
# Modification Instructions: This section of the configuration file contains
# information generated by the configuration program. Do not modify this
# section.
# You are free to modify everything else. Also, this section must start
# on a new line
# This file will get backed up with a different name in the same directory
# if this section is edited and you try to configure DHCP again.

# Written at: 07/09/2019 18:53:24
allow unknown-clients;
default-lease-time 1800;                # default is 30 minutes
max-lease-time 7200;                    # default is 2 hours

subnet 172.16.248.0 netmask 255.255.255.0 {
	range 172.16.248.128 172.16.248.254;
	option broadcast-address 172.16.248.255;
	option domain-name-servers 172.16.248.1;
	option domain-name localdomain;
	default-lease-time 1800;                # default is 30 minutes
	max-lease-time 7200;                    # default is 2 hours
}
host vmnet1 {
	hardware ethernet 00:50:56:C0:00:01;
	fixed-address 172.16.248.1;
	option domain-name-servers 0.0.0.0;
	option domain-name "
";
}
####### VMNET DHCP Configuration. End of "DO NOT MODIFY SECTION" #######
`, wantErr: false},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			f, err := ioutil.TempFile("", "test")
			if err != nil {
				t.Fatal(err)
			}

			err = ioutil.WriteFile(f.Name(), []byte(tt.args), 0666)
			if err != nil {
				t.Fatal(err)
			}

			_, err = ReadDhcpConfig(f.Name())
			if (err != nil) != tt.wantErr {
				t.Errorf("ReadNetmapConfig() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
		})
	}
}

func TestReadFusionNetworkingConfig(t *testing.T) {
	tests := []struct {
		name    string
		args    string
		wantErr bool
	}{
		{name: "CorrectFusionNetworkingConfig", args: `VERSION=1,0
answer VNET_1_DHCP yes
answer VNET_1_DHCP_CFG_HASH 0D3DCF0296EFCD8A2E0C1B238BC0009261F621D4
answer VNET_1_HOSTONLY_NETMASK 255.255.255.0
answer VNET_1_HOSTONLY_SUBNET 172.16.248.0
answer VNET_1_VIRTUAL_ADAPTER yes
answer VNET_8_DHCP yes
answer VNET_8_DHCP_CFG_HASH C55561C39C4974F9929F02C647F1186677A68A4A
answer VNET_8_HOSTONLY_NETMASK 255.255.255.0
answer VNET_8_HOSTONLY_SUBNET 192.168.98.0
answer VNET_8_NAT yes
answer VNET_8_VIRTUAL_ADAPTER yes
add_bridge_mapping en0 2
`, wantErr: false},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			f, err := ioutil.TempFile("", "test")
			if err != nil {
				t.Fatal(err)
			}

			err = ioutil.WriteFile(f.Name(), []byte(tt.args), 0666)
			if err != nil {
				t.Fatal(err)
			}

			_, err = ReadNetworkingConfig(f)
			if (err != nil) != tt.wantErr {
				t.Errorf("ReadNetmapConfig() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
		})
	}
}
